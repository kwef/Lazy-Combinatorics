{-# LANGUAGE TupleSections #-}

module Cartesian where

import Data.List
import Data.Maybe
import Data.Composition
import Control.Arrow
import Control.Applicative
import Control.Monad.Plus
import Safe

-- | Cartesian product of two (possibly infinite) lists with every element at a finite index in the resultant list. This is a "fair" cartesian product, which means that it doesn't give more elements from one list than the other on average.
cartesian :: [a] -> [b] -> [(a,b)]
cartesian = (concat . diagonalize) .: pairSpace

-- | Given a list of as and a list of bs, return a list of lists of pairs of as and bs.
pairSpace :: [a] -> [b] -> [[(a,b)]]
pairSpace = pairSpaceWith (,)

-- | Map a binary function over a space of pairs generated by two given lists.
pairSpaceWith :: (a -> b -> c) -> [a] -> [b] -> [[c]]
pairSpaceWith f xs ys = (\x -> (\y -> f x y) <$> ys) <$> xs

-- | Find the diagonals of a list of lists. If you conceive of each inner list as a "horizontal" row in an outer "vertical" list, then this traverses the list starting at the upper left corner, in diagonals going from lower left to upper right.
diagonalize :: [[a]] -> [[a]]
diagonalize =
   unfoldr (\(n,xss) ->
      partial (not . null . fst)
      . second (succ n,)
      $ stripN n xss)
   . (1,)

-- | Given a number n and a list of lists, return a pair consisting of: the heads of the first n lists, and the original list-of-lists without those elements.
stripN :: Int -> [[a]] -> ([a],[[a]])
stripN n xss =
   (mapMaybe headMay firstN,
    mapMaybe tailMay firstN ++ rest)
   where (firstN,rest) = splitAt n xss
